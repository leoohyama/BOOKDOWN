# Module 4

## 4A. Generalized Models

```{r}
library(tidyverse)
library(emmeans)
library(car)
library(agridat)
```

### Example: Conducting a one-way ANOVA with non-normal data

Let's load up the InsectSprays data
```{r}
data("InsectSprays")# available from base R  
```

Now we need to filter the data to just 4 treatments:
```{r}
d <- InsectSprays %>% filter(spray=='A'|spray=='B'|spray=='C'|spray=='F') %>% 
  droplevels()
```

Let's plot out data:
```{r}
ggplot(d, aes(x=spray,y=count)) + 
  geom_boxplot(outlier.shape = NA) + 
  geom_jitter(height=0,width=.1) +
  theme_classic() +
  theme(axis.title = element_text(face= 'bold', size = 15))
```

```{r}
hist(d$count)
```

Now let's construct a linear model to examine the effect of the different sprays on insect counts:
```{r}
lm1 <- lm(count~spray, data=d)
Anova(lm1, type=2)  ## car::Anova will print out an ANOVA table
```

Let's check the residuals of the model:
```{r}
hist(resid(lm1)) #' residuals should be normally distributed, even for glm
plot(resid(lm1)~fitted(lm1))   ## residuals should be evenly dispersed around 0 across the range of x's
abline(h=0)     # funnel shapes or curvature is bad
```

```{r}
qqPlot(resid(lm1))  ## residuals should line up pretty closely to the blue line
```

```{r}
boxplot(resid(lm1) ~ d$spray)  ## variances should be homogeneous for each group
```

Let's use emmeans:
```{r}
emmeans(lm1, ~spray)
```

Note all the SE are the same and CL is off.

### Log-linear model 

Now let's use a log-linear model to examine the effect of the different sprays on insect counts.
```{r}
lm2 <- lm(log(count+1)~spray, data=d)
Anova(lm2, type=2)  ## car::Anova will print out an ANOVA table testing
```

Let's check residuals:
```{r}
hist(resid(lm2)) ## residuals should be normally distributed, even for glm
plot(resid(lm2)~fitted(lm2)) +  ## residuals should be evenly dispersed around 0 across the range of x's
  abline(h=0)                               # funnel shapes or curvature is bad
```

qqPlot and boxplot next:
```{r}
qqPlot(resid(lm2))  ## residuals should line up pretty closely to the blue line
boxplot(resid(lm2) ~ d$spray)  ## variances should be homogeneous for each group
```

Let's use emmeans again:
```{r}
emmeans(lm2, ~spray) ## note that now all means are back-transformed

```

To calculate back-transformed emmeans we can add additional arguments:
```{r}
emmeans(lm2, ~spray, type='response') ## note that now all means are back-transformed
```

### Generalized linear models 

Now let's use GLMs to examine the effect of the different sprays:

```{r}
glm1 <- glm(count~spray, data=d, family='poisson') 
```

glm() is a general function that conducts a generalized linear model
and we must specify the 'family' (aka error distribution). The default is the 'gaussian' distribution (normal). All the model "calculations" are saved in an object we called 'glm1'.

```{r}
Anova(glm1, type=2)  ## car::Anova will print out an ANOVA table testing 
```

For the ANOVA above, the null hypothesis that all group means are equal. The argument, type = 2, provides margin tests, which is usually better than the default Type I, especially for more complicated models. For GLMs, Anova returns a likelihood ratio test with a chi-sq value

```{r}
summary(glm1)   ## summary() will provide the model coefficients (ie. the "guts" of the model)
```

The coefficients allow you rebuild the means from the linear model. Rebuilding the model from the coefficients is not super helpful and the p-values aren't very meaningful. Residual deviance should be about equal to the degrees of freedom. More than twice as high is problematic.

Now let's check assumptions of model by examining residuals:
```{r}
hist(resid(glm1)) ## residuals should be normally distributed, but don't need to be for GLMs
plot(resid(glm1)~fitted(glm1))  ## residuals should be evenly dispersed around 0 across the range of x's
abline(h=0)                               # funnel shapes or curvature is bad
```

```{r}
qqPlot(resid(glm1))  ## calls from car package, residuals should line up pretty closely to the blue line
# points that drift from line might be outliers
boxplot(resid(glm1) ~ d$spray)  ## variances should be homogeneous for each group
```

Diagnosing more complex GLMs can be very difficult. Residuals are often NOT NORMALLY DISTRIBUTED. We will return to this later...

```{r}
emmeans(glm1, ~spray) ## emmeans::emmmeans will rebuild the model for you
```

The emmeans code above will print off the means, SE, and confidence intervals for each treatment group. Note, the coefficients are on the log-scale (look at model).

```{r}
emmeans(glm1, pairwise~spray, type='response')  ## adding 'pairwise' will conduct pairwise contrasts -- ie. compare each group mean to the others
```

Adding the argument 'pairwise' will conduct pairwise contrasts -- ie. compare each group mean to the others. This automatically adjusts p-values using the 'tukey' adjust. This can be changed using 'adjust=XX' within the emmeans function. The type='response' will back-transform (ie. exponentiate) to the original scale   


Let's compare residuals for normal, log-transformed, and poisson models:
```{r}
par(mfrow=c(1,3))
boxplot(resid(lm1) ~ d$spray) 
boxplot(resid(lm2) ~ d$spray) 
boxplot(resid(glm1) ~ d$spray) 

dev.off()
```

Let's also compare means for normal, log-transformed, and poisson models:
```{r}
emmeans(lm1, ~spray)
emmeans(lm2, ~spray, type='response')
emmeans(glm1, ~spray, type='response')
```

## 4B. Overdispersion

In this section we will go over how to deal with overdispersion.

Let's load the necessary libraries:
```{r}
library(tidyverse)
library(emmeans)
library(car)
library(agridat)
```

Load in and read about the beall.webworms dataset. The variables of interest are the y-count of webworms, spray-spray treatment, and lead-lead treatment. Don't worry about the block or other variables for now.

```{r}
data("beall.webworms")
d1 <- beall.webworms
```

```{r}
head(d1)
```

Let's examine and plot the data:
```{r}
ggplot(d1, aes(x=spray, y=y, fill=lead)) + 
  geom_violin(scale="width", adjust=2) + 
  geom_point(position = position_jitterdodge(jitter.width=.5,
                                             jitter.height=.1,
                                             dodge.width = 1),
             alpha=.1) +
  theme_bw(base_size = 14)
```

Let's now run a model with the interaction of spray and lead.
```{r}
r3 <- glm(y ~ spray * lead, data=d1, family="poisson")
```

Examine the model summary:
```{r}
summary(r3)
Anova(r3)
emmeans(r3, ~spray:lead, type='response') 
```

We need to load library(performance) to test for overdispersion:
```{r}
library(performance)
check_overdispersion(r3) # overdispersion ratio calculator from RVAideMemoire
```

Now let's load the glmmTMB package to implement negative binomial distribution.
```{r}
library(glmmTMB)
r4 <- glmmTMB(y ~ spray * lead, data=d1, family="nbinom2")
Anova(r4)
emmeans(r4, ~spray:lead, type='response') 
```

Let's use the DHARMa package to simulate residuals for poisson and negative binomial models.
```{r}
library(DHARMa)
```
We can interpret the simulated residuals very similarly to the raw residuals we have previously examined. The residuals should line up along the line in the QQ plot and there should be (roughly) equal scatter in the residuals among the groups
```{r}
plot(simulateResiduals(r3)) ## plot simulated residuals
```

Histograms of the simulated residuals will be different than before. Here the simulated residuals should be flat. Its ok if the bars bump up and down, but they should be on average flat across the graph.The bars shouldn't be peaked (eg. "normally" distributed) or U-shaped or increasing/decreasing.
```{r}
hist(simulateResiduals(r3)) ## histogram should be flat
```

Now let's look at residuals for negative binomial model:
```{r}
plot(simulateResiduals(r4)) ## plot simulated residuals
hist(simulateResiduals(r4)) ## histogram should be flat
```

## 4C. Binomial GLM

In this section we will run a GLM with a binomial error distribution. We load the following packages:
```{r}
library(tidyverse)
library(emmeans)
library(car)
library(agridat)
library(DHARMa)
```

We will use the Titanic survival dataset for the binomial GLM.
```{r}
## LOAD TITANIC SURVIVAL DATASET
data("TitanicSurvival")
t1 <- TitanicSurvival %>% filter(age>17) # filter out children
head(t1)
```

Let's quickly plot the data:
```{r}
ggplot(t1, aes(x=passengerClass, y=survived, color=sex)) +
  geom_jitter(height=.2, width=0.2)
```

Now we can construct a GLM to estimate survival as a function of sex and passengerClass while include Age as co-variate.
```{r}
tglm1 <- glm(survived ~ sex * passengerClass + age, data=t1, family = binomial(link = "logit"))
```

Let's look at the summary of the model:
```{r}
## print off anova table
Anova(tglm1)
## print off summary
summary(tglm1)
```

Now we can check residuals:
```{r}
hist(resid(tglm1)) ## residuals should be normally distributed, even for glm
plot(resid(tglm1)~fitted(tglm1)) +  ## residuals should be evenly dispersed around 0 across the range of x's
  abline(h=0)                               # funnel shapes or curvature is bad
```

```{r}
qqPlot(resid(tglm1))  ## residuals should line up pretty closely to the blue line
boxplot(resid(tglm1) ~ t1$passengerClass)  ## variances should be homogeneous for each group
```

```{r}
## simulate residuals
plot(simulateResiduals(tglm1)) ## plot simulated residuals
hist(simulateResiduals(tglm1)) ## histogram should be flat
```

To make sense of the model output let's use the emmeans package:
```{r}
emmeans(tglm1, pairwise ~ sex:passengerClass)
```

We can obtain back-transformed means:
```{r}
emmeans(tglm1, pairwise ~ sex:passengerClass, type="response")      ## type= does contrasts before back-transforming (more appropriate!)
```

In order to plot we need to create new variable that is 0 or 1.
```{r}
t1$surv <- if_else(t1$survived=='yes',1,0)
```

Now we can make a plot with regression lines:
```{r}
ggplot(t1, aes(x=age, y=surv, color=sex)) + 
  geom_jitter(height=.1, width=0) + 
  geom_smooth(method="glm",
              method.args=list(family="binomial"), 
              formula = y ~ x, se=F, lwd=1.5) +
  facet_wrap(~passengerClass) +
  theme_bw(base_size = 20)
```

We can improve the aesthetics of the plot:
```{r}
tm <- emmeans(tglm1, ~ sex:passengerClass, type="response") %>% as.data.frame()
cbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

plot1 <- ggplot() +
  geom_jitter(data=t1 %>% filter(sex=='female'),
              aes(x=passengerClass, y=surv+.01),
              height=0, width=.25, size=1, 
              alpha=.1, color="#E69F00") +
  geom_jitter(data=t1 %>% filter(sex=='male'), 
              aes(x=passengerClass, y=surv-.01), 
              height=0, width=.25, size=1, 
              alpha=.1, color="#56B4E9") +
  geom_errorbar(data=tm,
                aes(x=passengerClass,
                    y=prob, ymin=(prob-SE), 
                    ymax=(prob+SE), color=sex), 
                width=.2, lwd=1.25,
                position = position_dodge(width=0.5)) +
  ## make bars thinner
  geom_point(data=tm , 
             aes(x=passengerClass, y=prob, color=sex), 
             size=5, 
             position=position_dodge(width=0.5)) + 
  scale_y_continuous('survival', labels = scales::percent) +
  scale_color_manual(values=cbPalette) +
  theme(panel.background = element_blank(),                           
        panel.border = element_rect(color="black",
                                    fill=NA, size=2)) +
  theme(axis.ticks.length=unit(0.3, "cm"),  
        axis.text.x =  element_text(margin=margin(5,5,5,5,"pt"),colour="black"),
        axis.text.y = element_text(margin=margin(5,5,5,5,"pt"),colour="black")) +  ## change axis tick marks to make them a little longer
  #theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(text = element_text(size=20)) 
plot1
```


```{r}
plot2 <- ggplot() +
  geom_jitter(data=t1 ,
              aes(x=passengerClass, y=surv, 
                  color=passengerClass), 
              height=.01, width=.35, 
              size=1, alpha=.2) +
  geom_errorbar(data=tm ,
                aes(x=passengerClass,
                    y=prob, ymin=(prob-SE),
                    ymax=(prob+SE), 
                    color=passengerClass), 
                width=.2, lwd=1.25) + ## make bars thinner
  geom_point(data=tm , 
             aes(x=passengerClass, 
                 y=prob, color=passengerClass), size=5) +
  facet_wrap(~sex) +
  scale_y_continuous('survival', labels = scales::percent) +
  scale_color_manual(values=cbPalette) +
  theme(panel.background = element_blank(),                           
        panel.border = element_rect(color="black", fill=NA, size=2)) +
  theme(axis.ticks.length=unit(0.3, "cm"),  
        axis.text.x = element_text(margin=margin(5,5,5,5,"pt"),colour="black"),
        axis.text.y = element_text(margin=margin(5,5,5,5,"pt"),colour="black")) + 
  theme(text = element_text(size=20)) 
plot2
```


## Gamma GLM

In this section we will learn about implementing the Gamma distribution in R. This distribution is helpful in for modeling a variety of data but is most frequently applied to data that is right skewed but not necessarily count data. The next several examples will illustrate how to generate Gamma distributed data based on several parameters as well as how to implement Gamma GLMs.

### Example 1

Here we generate a distribution:
```{r}
set.seed(15)
var1 <- rgamma(1000, shape = 2, scale = .5)
hist(var1, main='mean=1, scale=0.5')
```

Note that the mean of this distribution should be 1 because the mean is equal to product of the shape parameter and scale parameter. So, 2 multiplied by 0.5 should be 1.

```{r}
set.seed(15)
g1 <- glmmTMB(var1 ~ 1, family=Gamma(link="inverse"))
g1
## mean should be 1 with inverse link function
1/0.9711
```
In the above example we run a Gamma GLM as an intercept only model. By running an intercept only model we assume no other predictors can predict the response variable. Therefore the output from this model would simply be the mean of the response, which should be ~1 (which it is after applying the right link function to the intercept).

```{r}
g1a <- glmmTMB(var1 ~ 1, family=Gamma(link="log"))
g1a
## mean should be 1 with log link function
exp(0.02937)
```

The same is shown above but in this case we use a log link and so to back transform the intercept we use exponentiation. 

### Example 2

In the example below we generate another Gamma distributed variable but we change the shape and scale parameter. But because the mean is based on the product of the two, the mean remains as 1.

```{r}
set.seed(15)
var1 <- rgamma(1000, shape = 4, scale = .25)
hist(var1, main='mean=1, scale=0.25')

# mean = a (shape) * b (rate)
# mean = 4 * .25 = 1.0

g1 <- glmmTMB(var1 ~ 1, family=Gamma(link="inverse"))
g1
## mean should be 1 with inverse link function
1/0.9711

g1a <- glmmTMB(var1 ~ 1, family=Gamma(link="log"))
g1a
## mean should be 1 with log link function
exp(0.02937)

```
We once again repeat the same exercise as example 1 and see that when the appropriate back transformation based on link functions are applied to the intercept, it results in the original mean. 

### Example 3

In this example we change the mean of the distribution to 0.5 by changing the shape and scale parameters to 1 and 0.5 respectively. We then repeat the previous examples and run the inverse and log link Gamma GLMs and observe how the intercepts are backtransformed to approximate the previously set mean value. 

```{r}
set.seed(15)
var1 <- rgamma(1000, shape = 1, scale = .5)
hist(var1, main='mean=0.5, scale=0.5')

# mean = a (shape) * b (rate)
# mean = 1 * .5 = 0.5

g1 <- glmmTMB(var1 ~ 1, family=Gamma(link="inverse"))
g1
## mean should be 1 with inverse link function
1/g1$sdr$par.fixed[1]
```

```{r}
g1a <- glmmTMB(var1 ~ 1, family=Gamma(link="log"))
g1a$sdr$par.fixed[1]

## mean should be 1 with log link function
exp(g1a$sdr$par.fixed[1])
```

### Example 4

This example follows the previous examples but with the mean changed to 0.25.
```{r}
set.seed(15)
var1 <- rgamma(1000, shape = .5, scale = 1)
hist(var1, main='mean=0.25, scale=1')

# mean = a (shape) * b (rate)
# mean = .5 * 1 = 0.5

g1 <- glmmTMB(var1 ~ 1, family=Gamma(link="inverse"))
g1
## mean should be 1 with inverse link function
1/g1$sdr$par.fixed[1]
```

```{r}

g1a <- glmmTMB(var1 ~ 1, family=Gamma(link="log"))
g1a
## mean should be 1 with log link function
exp(g1a$sdr$par.fixed[1])

```

## Running Gamma GLMs

In this section we simulate data for two groups:
```{r}
set.seed(25)
v1 <- rgamma(100, shape = 3, scale = .5) %>% as.data.frame()
colnames(v1) <- "var"
v1$group <- "one"
head(v1)
v2 <- rgamma(100, shape = 1, scale = .2) %>% as.data.frame()
colnames(v2) <- "var"
v2$group <- "two"
head(v2)
```

Then bind the two groups into one dataset:
```{r}
dat1 <- rbind(v1,v2) #mean group 1 = 1.5, group 2 = 0.5
dat1 %>% mutate(obs=rep(1:100,2)) %>% group_by(obs) %>% pivot_wider(names_from = group,values_from = var) %>% 
  ungroup() %>% select(one,two)

```

We then check the data distributions:
```{r}
hist(dat1$var)
```

```{r}
ggplot(dat1, aes(x=var)) + geom_histogram(bins=8, fill="grey", color="black") + 
  facet_wrap(~group, scales="free") + theme_bw(base_size = 16)
```

Then we construct several different models and use AIC to compare models:

```{r}
#### construct model w/ normal distribution
mod0 <- glmmTMB(var ~ group, data=dat1)
plot(simulateResiduals(mod0))
summary(mod0)
emmeans(mod0, ~group, type="response")
```

```{r}
#### construct model w/ log-normal distribution
mod0a <- glmmTMB(log(var) ~ group, data=dat1)
plot(simulateResiduals(mod0a))
summary(mod0a)
emmeans(mod0a, ~group, type="response")
```

```{r}
#### construct model w/ Gamma distribution and inverse link
mod1 <- glmmTMB(var ~ group, data=dat1, family=Gamma(link = "inverse"))
plot(simulateResiduals(mod1))
summary(mod1)
emmeans(mod1, ~group, type="response")
```

```{r}
#### construct model w/ Gamma distribution and log link
mod2 <- glmmTMB(var ~ group, data=dat1, family=Gamma(link = "log"))
plot(simulateResiduals(mod2))
summary(mod2)
emmeans(mod2, ~group, type="response")
```

AIC:
```{r}
AIC(mod0,mod0a,mod1,mod2)
```

Which model is the best ranked model? 











